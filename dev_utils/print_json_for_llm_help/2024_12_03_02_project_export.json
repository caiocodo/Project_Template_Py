{
    "main.py": "def main() -> None:\n    print(\"main\")\n\n    run_mode = \"print_files\"\n    # Valores válidos:\n    # run -> execução normal\n    # debug -> execução com prints de debug (implemente no seu código)\n    # print_files -> execução gera um arquivo JSON com o conteúdo dos arquivos da variável file_paths.\n    #   o arquivo será gerado na pasta output_folder. \n    #   o JSON serve para ser compartilhado com LLMs como chatgpt e claude!!!\n\n    log_file = \"output.log\"\n    # Neste arquivo, serão salvas todas as saídas do programa.\n    # Tudo o que é impresso no console, também será salvo neste arquivo.\n\n    if run_mode == \"print_files\":\n        from dev_utils.print_json_for_llm_help import print_json_for_llm_help\n        # Caminhos podem ser:\n        # 1- relativos ao diretorio do projeto\n        # 2- absolutos\n        file_paths = [\n            r\"main.py\",\n            r\"README.md\",\n            r\"shared_vars.py\",\n            r\"dev_utils/console_log.py\",\n            r\"dev_utils/print_json_for_llm_help.py\",\n            r\"dev_utils/time_stamp.py\",\n\n            ]\n        output_folder = f\"dev_utils/print_json_for_llm_help\"\n        print_json_for_llm_help(file_paths, output_folder)\n        return\n\n    # Variáveis globais substituem argumentos repetitivos.\n    # Para acessar as variáveis globais, use:\n    import shared_vars\n    shared_vars.shared_state.run_mode = run_mode\n\n    # Iniciando a escrita no arquivo de log\n    from dev_utils.console_log import start_logging, stop_logging\n    start_logging(log_file)\n\n    # Importando a função de timestamp\n    from dev_utils.time_stamp import time_stamp_str\n\n    try:\n        print(\"<output_log>\")\n        print(time_stamp_str() + \"Starting Project\")\n        # >>>> Start your code here <<<<\n    finally:\n        print(\"<\\output_log>\")\n        stop_logging()\n\n    \nif __name__ == \"__main__\":\n    print(\"starting Main.py\")\n    main()",
    "README.md": "# Como usar\n\n1. Baixe este template no formato zip ou clone este repositorio.\n2. Renomeie a pasta PROJECT_TEMPLATE_PY para o nome do seu projeto\n3. Abra o arquivo `main.py` no seu editor de código preferido.\n4. Leia atentamente todo o código do arquivo `main.py`\n5. Não é necessário ler os demais arquivos, todas as explicações são feitas em comentarios na função `main()`. \n2. Modifique as variáveis que estão sendo inicializadas na função `main()`.\n3. Comece a escrever seu próprio código onde está indicado no arquivo `main.py`.\n\nPronto! Agora você pode usar este template para iniciar seu próprio projeto em Python.",
    "shared_vars.py": "# shared.py\n# Este arquivo é utilizado para compartilhar variáveis entre os arquivos do projeto.\nclass SharedState:\n    def __init__(self):\n        self.run_mode = \"\"\n\nshared_state = SharedState()\n",
    "console_log.py": "\nimport sys\n\nclass DualOutput:\n    def __init__(self, arquivo):\n        self.terminal = sys.__stdout__\n        self.arquivo = open(arquivo, 'a')\n\n    def write(self, mensagem):\n        self.terminal.write(mensagem)\n        self.arquivo.write(mensagem)\n\n    def flush(self):\n        self.terminal.flush()\n        self.arquivo.flush()\n\n    def close(self):\n        self.arquivo.close()\n\n# Variável para armazenar o stdout original\n_stdout_original = sys.stdout\n\ndef start_logging(arquivo: str = 'output.log') -> None:\n    \"\"\"Inicia o redirecionamento de stdout para o arquivo especificado.\"\"\"\n    global _stdout_original\n    sys.stdout = DualOutput(arquivo)\n\ndef stop_logging() -> None:\n    \"\"\"Para o redirecionamento de stdout e restaura o stdout original.\"\"\"\n    global _stdout_original\n    if isinstance(sys.stdout, DualOutput):\n        sys.stdout.close()\n        sys.stdout = _stdout_original\n",
    "print_json_for_llm_help.py": "import json\nimport os\nimport datetime\n\ndef print_json_for_llm_help(file_paths: list, output_folder: str) -> None:\n    # gera um arquivo JSON com o conteúdo dos arquivos da lista file_paths na pasta output_folder.\n    # o JSON serve para ser compartilhado com LLMs como chatgpt e claude, que servirão como assistentes do desenvolvimento do projeto. \n\n    # Create the output file name with the date and counter\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n    date_str = datetime.datetime.now().strftime(\"%Y_%m_%d\")\n    counter = 1\n    while True:\n        output_file = output_folder + f\"\\\\{date_str}_{counter:02d}_project_export.json\"\n        if not os.path.exists(output_file):\n            break\n        counter += 1\n\n    code_data = {}\n    for file_path in file_paths:\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                code_data[os.path.basename(file_path)] = f.read()\n        except FileNotFoundError:\n            raise ValueError(f\"File not found: {file_path}\")\n        except Exception as e:\n            raise ValueError(f\"An error occurred while processing {file_path}: {e}\")\n\n    # Save the data to the JSON file\n    with open(output_file, 'w', encoding='utf-8') as json_file:\n        json.dump(code_data, json_file, indent=4, ensure_ascii=False)\n        \n    print(f\"\\n{output_file} saved\\n\")\n",
    "time_stamp.py": "from datetime import datetime\n\ndef time_stamp_str() -> str:\n    # Retorna uma string com um timestamp no formato: \"YYYYy_MMm_DDd_HHh_MMm_SSs_mmmms\"\n    # Usado para marcar o tempo de execução de funções\n    now = datetime.now()\n    milliseconds = now.microsecond / 1000\n    milliseconds_formatted = f\"{int(milliseconds // 1):03}.{int((milliseconds % 1) * 1000):03}\"\n    return f\"{now.year}y_{now.month:02}m_{now.day:02}d_{now.hour:02}h_{now.minute:02}m_{now.second:02}s_{milliseconds_formatted}ms: \""
}