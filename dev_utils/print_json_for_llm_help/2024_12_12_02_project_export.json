{
    "main.py": "def main() -> None:\n    print(\"main\")\n\n    run_mode = \"print_files\"\n    # Valores válidos:\n    # run -> execução normal\n    # debug -> execução com prints de debug (implemente no seu código)\n    # print_files -> execução gera um arquivo JSON com o conteúdo dos arquivos da variável file_paths.\n    #   o arquivo será gerado na pasta output_folder. \n    #   o JSON serve para ser compartilhado com LLMs como chatgpt e claude!!!\n\n    log_file = \"output.log\"\n    # Neste arquivo, serão salvas todas as saídas do programa.\n    # Tudo o que é impresso no console, também será salvo neste arquivo.\n    log_file_last_run = \"output_last_run.log\"\n    # Neste arquivo, será salva somente a última execução do programa.\n\n    if run_mode == \"print_files\":\n        from dev_utils.print_json_for_llm_help import print_json_for_llm_help\n        # Caminhos podem ser:\n        # 1- relativos ao diretorio do projeto\n        # 2- absolutos\n        file_paths = [\n            r\"main.py\",\n            r\"README.md\",\n            r\"shared_vars.py\",\n            r\"dev_utils/console_log.py\",\n            r\"dev_utils/print_json_for_llm_help.py\",\n            r\"dev_utils/time_stamp.py\",\n            r\"output.log\",\n            r\"output_last_run.log\",\n            ]\n        output_folder = f\"dev_utils/print_json_for_llm_help\"\n        print_json_for_llm_help(file_paths, output_folder)\n        return\n\n    # Variáveis globais substituem argumentos repetitivos.\n    # Para acessar as variáveis globais, use:\n    import shared_vars\n    shared_vars.shared_state.run_mode = run_mode\n\n    # Iniciando a escrita no arquivo de log\n    from dev_utils.console_log import start_logging, stop_logging\n    start_logging(log_file)\n\n    # Importando a função de timestamp\n    from dev_utils.time_stamp import time_stamp_str\n\n    try:\n        print(time_stamp_str() + \"Starting Project\")\n        # >>>> Start your code here <<<<\n    finally:\n        stop_logging(log_file, log_file_last_run)\n\n    \nif __name__ == \"__main__\":\n    print(\"starting Main.py\")\n    main()",
    "README.md": "# Como usar\n\n1. Baixe este template no formato zip ou clone este repositorio.\n2. Renomeie a pasta PROJECT_TEMPLATE_PY para o nome do seu projeto.\n3. Abra o arquivo `main.py` no seu editor de código preferido.\n4. Leia atentamente todo o código do arquivo `main.py`.\n5. Não é necessário ler os demais arquivos, todas as explicações são feitas em comentarios na função `main()`. \n3. Comece a escrever seu próprio código onde está indicado na função `main()`.",
    "shared_vars.py": "# shared.py\n# Este arquivo é utilizado para compartilhar variáveis entre os arquivos do projeto.\nclass SharedState:\n    def __init__(self):\n        self.run_mode = \"\"\n\nshared_state = SharedState()\n",
    "dev_utils/console_log.py": "import sys\nimport os\n\nclass DualOutput:\n    def __init__(self, arquivo):\n        self.terminal = sys.__stdout__\n        self.arquivo = open(arquivo, 'a')\n\n    def write(self, mensagem):\n        self.terminal.write(mensagem)\n        self.arquivo.write(mensagem)\n\n    def flush(self):\n        self.terminal.flush()\n        self.arquivo.flush()\n\n    def close(self):\n        self.arquivo.close()\n\n# Variável para armazenar o stdout original\n_stdout_original = sys.stdout\n\ndef start_logging(log_file: str = 'output.log') -> None:\n    \"\"\"Inicia o redirecionamento de stdout para o arquivo especificado.\"\"\"\n    global _stdout_original\n    sys.stdout = DualOutput(log_file)\n    print(\"<output_log>\")\n\ndef stop_logging(log_file: str = 'output.log', log_file_last_run: str = 'output_last_run.log') -> None:\n    \"\"\"Para o redirecionamento de stdout e restaura o stdout original.\"\"\"\n    global _stdout_original\n    if isinstance(sys.stdout, DualOutput):\n        print(\"</output_log>\")\n        sys.stdout.close()\n        sys.stdout = _stdout_original\n    # Salva a última execução após parar o logging\n    save_last_execution(log_file, log_file_last_run)\n\ndef save_last_execution(log_file, log_file_last_run) -> None:\n    \"\"\"\n    Salva o conteúdo da última execução delimitado por <output_log> e </output_log>\n    em um arquivo separado.\n    \"\"\"\n    if not os.path.exists(log_file):\n        print(f\"Log file {log_file} does not exist.\")\n        return\n\n    try:\n        with open(log_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        # Encontrar índices das marcações\n        start_indices = [i for i, line in enumerate(lines) if '<output_log>' in line]\n        end_indices = [i for i, line in enumerate(lines) if '</output_log>' in line]\n\n        if not start_indices or not end_indices:\n            print(\"Não foram encontrados blocos de execução no log.\")\n            return\n\n        # Assumindo que cada <output_log> tem um correspondente </output_log>\n        last_start = start_indices[-1]\n        last_end = end_indices[-1]\n\n        if last_end < last_start:\n            print(\"Marcação </output_log> encontrada antes de <output_log>.\")\n            return\n\n        # Extrair conteúdo da última execução\n        last_execution = ''.join(lines[last_start:last_end + 1])\n\n        # Salvar no arquivo separado\n        with open(log_file_last_run, 'w', encoding='utf-8') as f:\n            f.write(last_execution)\n\n    except Exception as e:\n        print(f\"Ocorreu um erro ao salvar a última execução: {e}\")\n",
    "dev_utils/print_json_for_llm_help.py": "import json\nimport os\nimport datetime\n\ndef print_json_for_llm_help(file_paths: list, output_folder: str) -> None:\n    # print_files -> execução gera um arquivo JSON com o conteúdo dos arquivos da variável file_paths.\n    #   o arquivo será gerado na pasta output_folder. \n    #   o JSON serve para ser compartilhado com LLMs como chatgpt e claude!!!\n\n    # Create the output file name with the date and counter\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n    date_str = datetime.datetime.now().strftime(\"%Y_%m_%d\")\n    counter = 1\n    while True:\n        output_file = output_folder + f\"\\\\{date_str}_{counter:02d}_project_export.json\"\n        if not os.path.exists(output_file):\n            break\n        counter += 1\n\n    code_data = {}\n    for file_path in file_paths:\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                #code_data[os.path.basename(file_path)] = f.read()\n                code_data[file_path] = f.read()\n        except FileNotFoundError:\n            raise ValueError(f\"File not found: {file_path}\")\n        except Exception as e:\n            raise ValueError(f\"An error occurred while processing {file_path}: {e}\")\n\n    # Save the data to the JSON file\n    with open(output_file, 'w', encoding='utf-8') as json_file:\n        json.dump(code_data, json_file, indent=4, ensure_ascii=False)\n        \n    print(f\"\\n{output_file} saved\\n\")\n",
    "dev_utils/time_stamp.py": "from datetime import datetime\n\ndef time_stamp_str() -> str:\n    # Retorna uma string com um timestamp no formato: \"YYYYy_MMm_DDd_HHh_MMm_SSs_mmmms\"\n    # Usado para marcar o tempo de execução de funções\n    now = datetime.now()\n    milliseconds = now.microsecond / 1000\n    milliseconds_formatted = f\"{int(milliseconds // 1):03}.{int((milliseconds % 1) * 1000):03}\"\n    return f\"{now.year}y_{now.month:02}m_{now.day:02}d_{now.hour:02}h_{now.minute:02}m_{now.second:02}s_{milliseconds_formatted}ms: \"",
    "output.log": "<output_log>\n2024y_12m_03d_13h_10m_41s_983.552ms: Starting Project\n</output_log>\n<output_log>\n2024y_12m_03d_13h_14m_42s_814.120ms: Starting Project\n</output_log>\n",
    "output_last_run.log": "<output_log>\n2024y_12m_03d_13h_14m_42s_814.120ms: Starting Project\n</output_log>\n"
}